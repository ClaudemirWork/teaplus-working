'use client';

import React, { useState, useEffect, useCallback, useRef } from 'react';
import Image from 'next/image';
import { Volume2, VolumeX, Play, RotateCcw, Trophy, Star, Sparkles, Heart, Zap, Gift } from 'lucide-react';
import './auditory-memory.css';

interface GameStats {
  level: number;
  score: number;
  highScore: number;
  coins: number;
  combo: number;
  lives: number;
}

const AuditoryMemoryGame: React.FC = () => {
  // Estados do jogo
  const [currentScreen, setCurrentScreen] = useState<'welcome' | 'game'>('welcome');
  const [gameState, setGameState] = useState<'idle' | 'playing' | 'listening' | 'success' | 'fail'>('idle');
  const [sequence, setSequence] = useState<number[]>([]);
  const [userSequence, setUserSequence] = useState<number[]>([]);
  const [currentNote, setCurrentNote] = useState<number | null>(null);
  const [isPlaying, setIsPlaying] = useState(false);
  const [soundEnabled, setSoundEnabled] = useState(true);
  const [showSuccess, setShowSuccess] = useState(false);
  const [showError, setShowError] = useState(false);
  const [showCombo, setShowCombo] = useState(false);
  const [showTreasure, setShowTreasure] = useState(false);
  const [confettiActive, setConfettiActive] = useState(false);
  const [coinsRaining, setCoinsRaining] = useState(false);
  
  // Estat√≠sticas
  const [stats, setStats] = useState<GameStats>({
    level: 1,
    score: 0,
    highScore: 0,
    coins: 0,
    combo: 0,
    lives: 3
  });

  // Configura√ß√£o do jogo
  const [sequenceLength, setSequenceLength] = useState(3);
  const [playbackSpeed, setPlaybackSpeed] = useState(800);
  
  // Refer√™ncias de √°udio
  const audioContextRef = useRef<AudioContext | null>(null);
  
  // Cores e frequ√™ncias dos bot√µes
  const buttons = [
    { color: 'btn-red', emoji: 'üéµ', freq: 261.63, name: 'D√ì' },
    { color: 'btn-orange', emoji: 'üé∂', freq: 293.66, name: 'R√â' },
    { color: 'btn-yellow', emoji: 'üéº', freq: 329.63, name: 'MI' },
    { color: 'btn-green', emoji: 'üéπ', freq: 392.00, name: 'F√Å' },
    { color: 'btn-blue', emoji: 'üé∏', freq: 440.00, name: 'SOL' },
    { color: 'btn-purple', emoji: 'üé∫', freq: 523.25, name: 'L√Å' }
  ];

  // Inicializar √°udio
  useEffect(() => {
    if (typeof window !== 'undefined') {
      audioContextRef.current = new (window.AudioContext || (window as any).webkitAudioContext)();
      
      // Carregar dados salvos
      const savedHighScore = localStorage.getItem('memoriaSonoraHighScore');
      const savedCoins = localStorage.getItem('memoriaSonoraCoins');
      
      if (savedHighScore) {
        setStats(prev => ({ ...prev, highScore: parseInt(savedHighScore) }));
      }
      if (savedCoins) {
        setStats(prev => ({ ...prev, coins: parseInt(savedCoins) }));
      }
    }

    return () => {
      if (audioContextRef.current) {
        audioContextRef.current.close();
      }
    };
  }, []);

  // Tocar nota musical
  const playNote = useCallback((frequency: number, duration: number = 400) => {
    if (!soundEnabled || !audioContextRef.current) return;

    const oscillator = audioContextRef.current.createOscillator();
    const gainNode = audioContextRef.current.createGain();
    
    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(frequency, audioContextRef.current.currentTime);
    oscillator.connect(gainNode);
    gainNode.connect(audioContextRef.current.destination);
    
    gainNode.gain.setValueAtTime(0, audioContextRef.current.currentTime);
    gainNode.gain.linearRampToValueAtTime(0.3, audioContextRef.current.currentTime + 0.01);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContextRef.current.currentTime + duration / 1000);
    
    oscillator.start(audioContextRef.current.currentTime);
    oscillator.stop(audioContextRef.current.currentTime + duration / 1000);
  }, [soundEnabled]);

  // Gerar nova sequ√™ncia
  const generateSequence = useCallback(() => {
    const newSequence = [];
    for (let i = 0; i < sequenceLength; i++) {
      newSequence.push(Math.floor(Math.random() * 6));
    }
    setSequence(newSequence);
    return newSequence;
  }, [sequenceLength]);

  // Tocar sequ√™ncia
  const playSequence = useCallback(async (seq: number[]) => {
    setIsPlaying(true);
    setGameState('listening');
    
    // Pequena pausa antes de come√ßar
    await new Promise(resolve => setTimeout(resolve, 500));
    
    for (let i = 0; i < seq.length; i++) {
      setCurrentNote(seq[i]);
      
      // Adicionar efeito visual ao bot√£o
      const button = document.getElementById(`btn-${seq[i]}`);
      if (button) {
        button.classList.add('btn-active');
        button.style.transform = 'scale(1.2)';
        button.style.boxShadow = '0 0 30px rgba(255,255,255,0.8)';
      }
      
      playNote(buttons[seq[i]].freq, 400);
      
      await new Promise(resolve => setTimeout(resolve, playbackSpeed));
      
      // Remover efeito visual
      if (button) {
        button.classList.remove(
